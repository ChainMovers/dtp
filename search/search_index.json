{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"For when you want some web2 on the web3 playground <ul> <li> <p> Create hybrid dApps</p> <p>Decentralized connection control, metering and crypto-economics \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ Your existing off-chain service and data.</p> </li> <li> <p> Security &amp; DDoS Protection</p> <ul> <li>Scalable firewall built-in the Sui network!</li> <li>Stop DDoS attacks even before it reaches your servers.</li> <li>Keep your Web2 servers IP hidden (visible only to Sui node operators).</li> </ul> <p> See firewall example...</p> </li> <li> <p> Privacy &amp; Authenticity</p> <ul> <li>On-chain secret exchanges. DTP always encrypt end-to-end. </li> <li>Secured key/certificate installation on web3 apps from centralized servers.</li> <li>Authenticity with signed data transfer.</li> </ul> </li> <li> <p> Open-Source</p> <ul> <li>Only code from developers for developers. No gimmick.</li> <li>No Token, middlemen, commission or dev fee.</li> <li>Only requires the smart contracts execution costs (the gas for the Sui Move calls).</li> </ul> <p> Check the FAQ...</p> </li> <li> <p> High Availability</p> <ul> <li> <p>Automatic failover and/or load balancing among your backend servers.</p> </li> <li> <p>Maybe your service would benefit from the censorship resistance of the Sui network?</p> </li> <li> <p>Develop Serf-like coordination with a group of other loosely coupled web2 servers.</p> </li> </ul> </li> <li> <p> Safe and Fair Hybrid Escrow</p> <ul> <li> <p>Add fair Tokenomics to Web2: Pay per request, per byte, per RPC call etc...</p> </li> <li> <p>DTP has built-in \"Response Fee Escrow\" to prevent query requesters to perform financial attacks against a company/server.</p> </li> </ul> </li> </ul> <p></p> <p></p> <p> Why Sui and not blockchain 'x' ? SUI has good finality latency stability (low jitter) and network scalability (maintains per connectin throughput regardless of total load).</p> <p>Sui architecture provides two type of transactions:</p> <ul> <li> <p>Simple Transaction with sub-second finality for data plane transfer (See \"partial ordering\" illustration). This allows fast async/parallel transmission.</p> </li> <li> <p>Narwhal/Bullshark consensus with 2-3 seconds finality used for slower control plane synchronization, like escrow services, reconfiguration, connection creation,etc...</p> </li> </ul> <p>With its dual-type of transactions with the proper set of qualities, Sui makes practical the implementation of common data + control plane design found in IP networks ( Cloudflare explains it well ).</p> <p>See How Sui Differs from Other Blockchains?</p> <p>Why not simply use the good old, faster and free internet?</p> <p>Join the Discord community and let's talk about it!</p>"},{"location":"community/","title":"DTP Community","text":"<p>Discord Invite:   https://discord.gg/Erb6SwsVbH</p> <p>Mario Fortier - Lead Developer</p> <ul> <li>LinkedIn: https://www.linkedin.com/in/mfortier/ </li> <li>Discord username : Mhax#6164</li> <li>Github username : https://github.com/mario4tier</li> </ul> <p>(Join, contribute and have your name added here...) </p>"},{"location":"examples/","title":"Applications Example","text":"<p>DTP provides networking building blocks that can be applied in many ways.</p> <p>You will find on this page a few inspiring ideas.</p> <p>DTP features are made available in roughly 3 layers (in increasing level of difficulty):</p> <ul> <li> <p>DTP Services Daemon Similar to NGINX/Cloudflare/HAProxy. These are for proxy/forward/firewall services. You will simply be configuring how your data flows between your apps and hosts.</p> </li> <li> <p>DTP Protocols Think \"TCP\". The DTP/Sui SDKs allows developers to create connections between web2 and web3 apps. You will need to write Rust and/or Typescript apps.</p> </li> <li> <p>DTP Sui Move Packages Innovations particular to Sui, such as RPC escrows, data streaming, coins&amp;call equivocation mitigation, metering etc... you will likely be deeply involve into web3 development at this point.</p> </li> </ul> <p>For most users, you will deal only with the \"easiest\" layer, the \"DTP Services Daemon\".</p> <p>If not sure how to proceed for your specific need, then please open a discussion on Discord.</p> <p>When ready  Go to choose your installation setup ....</p> <p>Client/Server</p> <ul> <li>Web3 frontends connecting to a centralized JSON-RPC backend (More info)</li> <li>Rust/Typescript Web3 Client to centralized TCP Server (More info)</li> </ul> <p>Encrypted Messaging</p> <ul> <li>Add traditional user/password login to a dApp. The goal is to allow access to the same \"user account\" even if done from a different wallet (client address). Implementation often requires \"secret messaging\" between a centralized server and the Web3 apps.</li> <li>Any user-to-user data transfer </li> <li>Anonymous Tips Line (with potential reward in return).</li> </ul> <p>Networking / Infrastructure</p> <ul> <li>Zookeeper, Consul, Serf-like services for discovery and consensus among off-chain servers.</li> <li>UDP, TCP, QUIC/UDP Tunneling: Transport IP protocols packets within a DTP connection for point-to-point applications (See DTP Services Daemon for an alternative)</li> </ul> <p>Firewall</p> <ul> <li>Rate limit access to a back-end server (either bandwidth or request)</li> <li>Allow/block origin (using authentication)</li> </ul> <p>Crypto-Economics</p> <ul> <li>Any service charging for content access (in addition to gas cost). DTP provides generic per byte and/or per request escrow service (to meter pre-agreed cost, limit and quantity... not quality).</li> <li>Pre-paid subscription per day/month (epoch driven?).</li> <li>Various escrow service that allows to shift the transport cost completely at the origin or destination (gas always paid by sender, but escrow service handles fair refund).</li> </ul> <p>Public Broadcasting</p> <ul> <li>Allow live broadcasting to automatically turn on/off upon enough fund contributed (thus saving the producer from any expense when no-one is listening).</li> <li>Public broadcast performed upon enough ticket sold.</li> <li>Tip/Request/Message/Audience participation line attach to a public event channel.</li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>In one sentence... What can DTP do?</p> <p>It is a TCP-Like protocol facilitating data streaming between web3 applications and optionaly allow safe access to traditional web2 TCP/IP services using a \"smart contract\" (DTP).</p> <p>Can DTP be used between Web3 apps?</p> <p>Yes.</p> <p>As an example, you can use it to efficiently let gamers stream data among themselves (P2P).</p> <p>What sort of data can DTP transport?</p> <p>Any protocol, any data stream.</p> <p>Data can be a few bytes for a one time secret exchange for authentication/login. At another extreme, the bandwidth can be for as much as an encrypted video stream (through the innovative combination of DTP Multi-channels and Sui network simple transactions). The economic feasibility of HD video streaming on blockchain is an open question...</p> <p>Can DTP be used with commercial application?</p> <p>Yes. DTP is open-source and can freely be used in commercial application (Apache 2.0 License).</p> <p>How much does it cost to use DTP?</p> <p>Only the Sui gas needed to run it, expect the execution cost to be mostly driven by the number of bytes transferred.</p> <p>There is no developer fee or commission collected for using DTP.</p> <p>When will DTP have token?</p> <p>Never. </p> <p>dApps built on top of DTP can use tokens or charge additional Mist, but this is not within the scope of DTP itself.</p> <p>Can DTP simply tunnel standard TCP, UDP, IP packets?</p> <p>Transparent packets tunneling could be done, but is not recommended.</p> <p>DTP/Sui provides already reliable and ordered data transport. That would be redundant with say, what TCP would try to achieve within a tunnel.</p> <p>Instead, look into DTP Services Daemon to efficiently terminate/bridge standard IP protocols. That eliminates protocol redundancy and better leverage what the Sui network already provide.</p> <p>Any plan to support another blockchain?</p> <p>No, unless a breakthrough in performance is possible with another blockchain architecture.</p> <p>Sui provides stable time to finality (low jitter), parallelism and scalability (no contention between connections).</p> <p>Low jitter allows small and predictable buffer size at the receivers.</p> <p>Sui simple transactions makes sub-second streaming latency possible.</p> <p>For now, DTP/Sui might not be well-suited for application that depends on fast sequence of query/response (since that requires two transactions finality). DTP attempts to minimize roundtrips and protocol handshakes at every step.</p> <p>Where is the code?</p> <p>DTP still in early design phase and is not yet release.  See GitHub development branches for \"work-in-progress\".</p> <p>Where can I go for more questions?</p> <p>Try the Discord channel: https://discord.gg/Erb6SwsVbH</p>"},{"location":"example/rpc_firewall/","title":"JSON-RPC Firewall","text":"<p>In this example, a Web3 application access a Web2 server providing a JSON-RPC API to its customer. </p> <p>One of the goal is to protect the Web2 server from DDoS attack, in particular, hide its IP address.</p> <p></p> <p>A DTP \"Services Daemon\" runs as a TCP/IP proxy on the same machine as the web2 server.</p> <p>Since the sender has to pay for all the data byte transmission costs through the Sui network, an attack is costly and mostly futile.</p> <p>The server IP address is visible only to the Sui nodes (not to the Web3 users on the other side of the Sui network). This mitigates direct traditional IP attacks. The server is not completely hidden, but the owner can control its Sui node partners (in similar way that one choose to, say, trust a reputable company such as Cloudflare).</p> <p>On the drawing, everything in green and blue is provided by DTP and the Sui infrastructure respectively. The application developer provides only what is shown in yellow.</p> <p>In this example the Web3 app contact the hidden web2 IP server using the <code>&lt;Host Object ID&gt;</code>:8923 address and DTP takes care of the safe data transfer.</p> <p>Work-In-Progress... there is more to it... such as mitigation with dynamic <code>&lt;Host ObjectID&gt;</code> to more than one origin IP mapping</p>"},{"location":"example/web3_rust/","title":"Web3 Client / Rust Server","text":"<p>Connect any frontend to both a centralized and decentralized backend.</p> <p></p> <p>Incomplete Documentation - Work-In-Progress</p>"},{"location":"ref/design/","title":"Sui Move Objects","text":""},{"location":"ref/design/#target-audience","title":"Target Audience","text":"<p>Developers should first read the API they intend to use.</p> <p>This document is for developers curious about DTP inner works.</p>"},{"location":"ref/design/#at-high-level-how-is-the-sui-network-used","title":"At high level, how is the Sui Network used?","text":"<p>Sui owned objects are used for unidirectional data transfer with sub-second latency (See Simple Transaction in Sui docs).</p> <p>Data Ingress: A data stream is sliced into transactions (txns) and added to the Sui network. The txns are targeted to a destination Pipe (owned object).</p> <p>Data egress: The data \"exit\" the network through event streams (emitted by the txns being received at the destination Pipe). The transmitted data can be \"observed\" by any users, but decoded only by the ones having the decryption key.</p> <p>The receiving end DTP SDK re-assembles the txns into the original data stream. The stream is then forwarded to the intended end-user (a TCP server, a Rust application layer above etc...).</p> <p>Slower transactions (Sui consensus) are used for most \"control plane\" synchronizations.</p>"},{"location":"ref/design/#dtp-glossary","title":"DTP Glossary","text":"<p>Client: An application that initiate a connection.</p> <p>Connection: One connection allows exchanging data between two applications. The applications are localized by their Host object on the Sui network. A connection will start to exchange data only after a Transport Control and one or two Pipe objects are created (for uni or bidirectional transfer respectively).</p> <p>Host Object: Any signature authority that want to transfer data must create its own Host object. This is a Sui shared object involved in many control plane transactions (e.g. creation of a connection). It allows to configure the services (and SLA) that are to be provided, the lifecycle of its associated connections and control the firewall.</p> <p>Objects: Usually refer to Sui objects (See Sui Docs)</p> <p>Pipe Object:All off-chain data exchange involves an intermediate object on the Sui network. This object is the Pipe. It is owned by the sender of the data, and have its event stream observed by the receiver(s). A Pipe is loosely coupled to a Transport or Broadcast Control object for synchronization.</p> <p>Server: Off-chain process intended to respond to client requests.</p> <p>Service Level Agreement (SLA): Specify the costs, limitations and some behaviors for a service provided by a Host object. Example would be \"sent data can be deleted from network storage after 48 hours (2 epochs)\". The client signifies that it agrees to an SLA at the time the connection to the node is initiated. The SLA specs are such that DTP can enforce the agreement fairly to all parties.</p> <p>Transport Control Object: Variables and state machines that exists for the lifetime of a single connection. This is a Sui shared object.</p>"},{"location":"ref/design/#firewall","title":"Firewall","text":"<p>(1) Gas cost of processing incoming traffic is paid by the sender. That includes connection creation cost and running the firewall at the Pipe Object. Most abuse can therefore be neutralized without requiring any processing/cost from the Server.</p> <p>Firewall functionality also includes back pressure management to minimize initiating/paying for transactions while the server is already known offline or too busy.</p> <p>(2) Optionally, the DTP Node Host object gather statistics from all its Pipe objects and adjust the rate limiting rules. This may happen when the Server detects excessive incoming traffic. The gas cost for these likely rare adjustments is to be handled by the Server. (Note: This is a logical representation. More details will follow on how this is implemented such that Pipe objects are not involved with slower consensus transactions).</p> <p>(3) The server configure the firewall and does a periodical heartbeat using its shared DTP Host object. The server may also do some fast detection and control on the firewall (TBD).</p> <p>(4) When a transaction has no-effect because of the firewall, there is no event emitted (and sender is informed that the transaction was executed, but blocked by the firewall). Therefore, the Server is not impacted.</p>"},{"location":"ref/design/#multi-channel-connection","title":"Multi-Channel Connection","text":"<p>Media byte streams are ineviteably divided into transaction \"block\" at some point. Even with a fast finality, the bandwidth is limited by the maximum transaction size and their serialization as allowed by the L1 network (e.g. one simple transaction per object and gas coin at the time).</p> <p>Therefore, to support high bandwidth, it might be needed to perform multiple transaction in parallel for a single connection transfer. These transaction flows through independent DTP channels.</p> <p>Most of the complexity is handled off-chain by DTP when dividing and re-assembling the transactions into a data stream:</p> <p></p> <p>Will this be practical? There is a lot of cost/performance unknowns with both Sui network and DTP that will probably persist through 2023. DTP architecture supports media streaming, but it remains to be seen how practical it will be.</p> <p>Gas might be expensive and there is some potential limitations about how much Sui fullnodes could scale on a viral broadcast (problem at egress of the network, not with the consensus performance itself).</p> <p>Light data streaming (&lt;20 Kbps) very likely to be supported and be useful within 2023.</p> <p>Regardless of practicality, support for multi-channel will be at least useful for demo/stress load on a test network.</p> <p>Some estimations (See on Google Sheet):</p> <p> (Note: Numbers are best guess as of 11/21/22. Will be revised from time to time)</p>"},{"location":"ref/design/#high-availability-and-load-balancing","title":"High-Availability and Load Balancing","text":"<p><p>Forwarding decision made by Pipe object when multiple end-points (servers) </p></p> <p>Off-chain servers can share the incoming load or be each other's fallback for high-availability.</p> <p>Unlike traditional network, the data is not physically pushed toward a server. Instead, the data remains on the network and an event is emitted about who should \"pull it\".</p> <p>It is an off-chain responsibility for the application to subscribe to their respective event stream (with proper identifier filtering) and normally retrieve only its assigned data (this change in some recovery scenario).</p> <p>Configuration of the end-points and health of the servers is managed through the DTP node, which in turn updates all its pipes and transport control objects.</p> <p>DTP will hide the high complexity of many race conditions (assignment to a server that died) and connection migrations among all end-points belonging to the same Node.</p>"},{"location":"ref/design/#uni-directional-transfer","title":"Uni-directional Transfer","text":"<p>Similar to bi-directionals, but with a single Pipe object for data plane to minimize cost/complexity. Control plane still bi-directional (e.g. for encryption handshake).</p> <p><p>Uni-Directional Data Transfer</p></p>"},{"location":"ref/design/#public-broadcasting","title":"Public Broadcasting","text":"<p>Similar to unidirectional, but without encryption and using Broadcast objects instead of a Pipe&amp;Transport control.</p> <p><p>Broadcasting Specific Objects</p></p> <p>Broadcasters may require some different crypto-economic capability. Examples:</p> <ul> <li>A live broadcast is wasteful if there is no one listening... one option will be to let DTP stop stream until there are enough fund from listeners to cover, say, the production cost of the next 1 minute. DTP would handle the automatic \"on air\" logic and fairly spread the cost among the contributors.</li> <li>Listener may choose to tip a live broadcaster (for special requests?).</li> </ul> <p>There are also some technical challenges particular to broadcasting (See Future Work).</p>"},{"location":"ref/future_work/","title":"Future Work","text":""},{"location":"ref/future_work/#broadcasting-challenges","title":"Broadcasting Challenges","text":"<p>Data broadcasting will put pressure on fullnodes WebSocket event streaming services.</p> <p>Fullnodes may have low economic incentive to support such high bandwidth services.</p> <p>The architecture should scale to match the audience size.</p> <p>Consequently, one possible long term solution is for DTP/Sui to provide only the crypto-economic services and then leave the burden of broadcasting to a public peer-to-peer network.</p> <p></p> <p>Each peer is running a DTP app for direct connection to the Sui network (for control plane). The complexity of the data plane transiting through a peer-to-peer network should be hidden to the end-users (Peers). </p> <p>The use of P2P or not remains irrelevant to the broadcaster which always interface directly to the Sui network.</p>"},{"location":"ref/future_work/#data-deletion","title":"Data Deletion","text":"<p>Once the data is confirmed consumed by the receiver(s), then it can be deleted on the L1 network to recover some storage fee  \u2192 Revisit the design needed here once Sui implements Storage fund.</p> <p>The sender of the data can opt out from automated deletion and assume the full storage cost.</p> <p>Automated deletion is controlled by DTP to provide a fair time for the receiver(s) to consume the data and can be fine tuned through the sender service level agreement (SLA).</p> <p>The SLAs are published by the server (in its Node object) and one is selected by the client at the time of the connection being established.</p>"},{"location":"ref/future_work/#data-consumption-confirmation","title":"Data Consumption Confirmation","text":"<p>TCP protocol includes acknowledgment of L4 delivery to the destination, but without guarantee of being consumed by the application (requires additional protocol at layer 7).</p> <p>DTP layer supports both; a confirmation of the data being available on the L1 network (TCP delivery equivalent) and optional confirmation of the client consuming the data (L7 protocol equivalent).</p> <p>Example of use would be to integrate in the dApps the verification that the data was persisted off-chain by the destination. There is no verification that the destination is honest, but this would be used in context where it would be in the destination best interest to act honestly.</p>"},{"location":"ref/future_work/#encrypted-broadcasting","title":"Encrypted Broadcasting","text":"<p>For now, broadcast are assumed to be always public and non-encrypted.</p> <p>Allowing encryption may allow alternative economic model (similar to cable and/or streaming subscription services<sup>1</sup>), but this is challenging and piracy can (at best) only be mitigated<sup>2</sup>.</p> <p>Only the user with the decryption key would be able to make sense of the data. More research to be done about how DTP could implement this feature.</p> <ol> <li> <p>Wikipedia Broadcast Encryption \u21a9</p> </li> <li> <p>Wikipedia Multicast Encryption \u21a9</p> </li> </ol>"},{"location":"ref/readme/","title":"Read Me First","text":""},{"location":"ref/readme/#basic-concept","title":"Basic Concept","text":"<p>Exchange of data through the SUI network can be done between any Web2 or Web3 application that includes the DTP and Sui SDKs.</p> <p>An application will first want to create its own \"unique contact point\" on the network by creating a \"Host Sui Object\" using the DTP API.</p> <p>An application can \"ping\" or \"connect\" to other Host object created by other apps. Each Host are uniquely identified by a \"Sui Object ID\".</p> <p>The typical <code>&lt;IP address&gt;:&lt;Port&gt;</code> becomes a <code>&lt;Host Object ID&gt;:&lt;Port&gt;</code></p>"},{"location":"ref/readme/#on-chain-firewall","title":"On-Chain Firewall","text":"<p>For security reason, each Host Object are by default created \"completely closed\". Using the DTP API, an application can choose to open ports of its Host object to progressively add services.</p> <p>Other application will be able to observe what other Host allow/block even before attempting to use their service. Even if an attacker try to use a service when they should not, it will be rejected by the DTP Move package on-chain, therefore have no impact on the destination.</p> <p>The DTP API allows fine grain control of allowance/blocking of particular requester, connection count or bandwidth limit. Configuration are kept and applied 24/7 on-chain.</p>"},{"location":"ref/readme/#connection-type-and-escrow","title":"Connection Type and Escrow","text":"<p>DTP provides traditional byte streaming (TCP-Like) connections between Host, but also the simplification of higher level connection, in particular RPC calls.</p> <p>When configuring a service for your Host, you must choose a \"Service Level Agreement\" that DTP will enforce.</p> <p>An example is to require the requester to pay for the cost of the response that your server will have to provide.</p> <p>This is a good example where adding Web3 qualities to an existing Web2 service creates API monetization without requiring huge security/edge infrastructure investments</p> <p>DTP defines a set of \"Typical\" service level agreement to help minimize market confusion. </p> Service Level Agreement Who Pays OpenDataStream Everyone pay for their own transactions (txns). AudioStream-Free Broadcaster only. JSON-RPC-BestEffort Everyone pay for their own txns. No response guaranteed. JSON-RPC-RequesterPaid RPC Requester pays. Responder refunded through escrow. Ping-RequesterPaid RPC Requester pays. Responder refunded through escrow. <p>The requester agree to the SLA upon creation of the connection and is enforced through DTP escrow for the connection duration. DTP handles the fund redistribution fairly with consideration of various success/failure criteria (more refinement will follow in ~2024).</p>"},{"location":"setup/help/","title":"Which setup?","text":""},{"location":"setup/help/#choice-1-of-3-simplified-dtp-services-deployment","title":"Choice 1 of 3: Simplified DTP Services Deployment","text":"<p>Choose this setup if you only need one of the following feature:</p> <ul> <li> <p>(Optional) Make your server API accessible on the Sui network (e.g. REST, JSON-RPC etc...)</p> </li> <li> <p>(Optional) Make a local directory content accessible on the Sui network (be a \"file server\")</p> </li> <li> <p>(Optional) Allow other user on the network to discover and ping your server.  </p> </li> </ul> <p></p> <p>Work-in-progress. Simplified deployment not yet available. For now, these functionalities are parts of the more complex Rust development setup</p>"},{"location":"setup/help/#choice-2-of-3-dtp-rust-development-setup","title":"Choice 2 of 3: DTP Rust Development Setup","text":"<p>Choose this setup if you need any of these:</p> <ul> <li> <p>Create a Sui Move package (with or without DTP)</p> </li> <li> <p>Create your own Rust application using DTP and/or Sui Rust SDK.  </p> </li> </ul> <p>Includes the Sui framework itself, the DTP Service Daemon and all the DTP scripts to facilitate local and devnet testing.  Go to Rust Setup ...</p>"},{"location":"setup/help/#choice-3-of-3-dtp-typescript-sdk-npm-package","title":"Choice 3 of 3: DTP Typescript SDK (NPM Package)","text":"<p>Typescript development not yet started. Schedule may depend on community/foundation demand</p>"},{"location":"setup/rust/","title":"Rust Development Setup Installation","text":""},{"location":"setup/rust/#follow-the-sui-installation","title":"Follow the Sui installation","text":"<p>https://docs.sui.io/build/install#prerequisites</p>"},{"location":"setup/rust/#clone-dtp","title":"Clone DTP","text":"<p>https://github.com/mario4tier/dtp</p>"},{"location":"setup/rust/#initialize-localnet","title":"Initialize localnet","text":"<p>Just run the DTP \"init-localnet\" and it will initialize the whole DTP setup and (re)start the \"sui\" localnet process as needed. </p> <p>The localnet will be re-initialized with always the same configuration, address and funding. (it uses its own configuration file at genesis for a deterministice setup).</p> <p>From this point use \"lsui\" and \"dsui\" shell scripts (as a direct replacement of \"sui\") to access localnet and devnet respectively.</p> <p>Output example: <pre><code>~/dtp$ ./dtp/script/init-localnet\nOutput location = /home/user/dtp-dev\nStopping running localnet (sui process pid 1317)\nBuilding localnet using latest Sui devnet branch...\n    Finished dev [unoptimized + debuginfo] target(s) in 1.29s\nRemoving existing /home/user/dtp-dev/localnet directory\nStarting new localnet process (may take up to 30 secs)\n.........\nNew localnet started (sui 0.20.0, process pid 6798)\n========\nlocalnet =&gt; http://0.0.0.0:9000 (active)\ndevnet =&gt; https://fullnode.devnet.sui.io:443\n========\nAll addresses with coins:\nShowing 5 results.\n0x267d4904898cbc15f165a18541154ec8c5732fcb\n0x68db58b41d97e4cf1ea7d9327036ebd306a7930a\n0x99d821380348ee02dd685a3af6d7123d92db0d3c\n0xbbd8d0695c369b04e9207fca4ef9f5f15b2c0de7\n0xe7f134729591f52cf0638c2500a7ed228033a9e7\n========\nAll coins owned by 0xe7f134729591f52cf0638c2500a7ed228033a9e7 (active):\n                 Object ID                  |  Gas Value\n----------------------------------------------------------------------\n 0x0b162ef4f83118cc0ad811de35ed330ec3441d7b | 100000000000000\n 0x2d43245a6af1f65847f7c18d5f6aabbd8e11299b | 100000000000000\n 0x9811c29f1dadb67aadcd59c75693b4a91b347fbb | 100000000000000\n 0xc8381677d3c213f9b0e9ef3d2d14051458b6af8a | 100000000000000\n 0xd0b2b2227244707bce233d13bf537af7a6710c01 | 100000000000000\n========\n\nRemember:\n  Use \"dsui\" to access devnet\n  Use \"lsui\" to access your localnet\n\nSuccess. Try it by typing \"lsui client gas\"\nhost:~/$\n</code></pre></p>"},{"location":"setup/rust/#publish-dtp-package-localnet","title":"Publish DTP Package (localnet)","text":"<p>~/dtp$ publish-localnet</p>"},{"location":"setup/rust/#run-dtp-integration-test-localnet","title":"Run DTP Integration Test (localnet)","text":"<p>~/dtp$ cargo test</p> <p>When running integration tests, the test setup makes sure a localnet (sui process) and a peer DTP service Daemon (dtp process) simulate interacting with a remote peer.</p> <p>This allows to automate your own client/server integration test of your own application on a single machine (Just need to make sure to use a different set of object coin, client address and localhost:port. More on this later).</p>"}]}