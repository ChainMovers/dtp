import{_ as r,a as l,b as c,c as d,d as p,e as h,f as u}from"./ref_broadcast-BFGBhm9s.js";import{_ as g}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as m,c as f,a as e,d as t,b as n,w as b,e as i}from"./app-BnFZaCe1.js";const v={},y=e("h2",{id:"target-audience",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#target-audience"},[e("span",null,"Target Audience")])],-1),w=e("p",null,"Developers should first read the API they intend to use.",-1),_=e("p",null,"This document is for developers curious about DTP inner works.",-1),T=e("h2",{id:"at-high-level-how-is-the-sui-network-used",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#at-high-level-how-is-the-sui-network-used"},[e("span",null,"At high level, how is the Sui Network used?")])],-1),k={href:"https://docs.sui.io/concepts/transactions/transaction-lifecycle",target:"_blank",rel:"noopener noreferrer"},P=i('<p>Data Ingress: A data stream is sliced into transactions (txns) and added to the Sui network. The txns are targeted to a destination Pipe (owned object).</p><p>Data egress: The data &quot;exit&quot; the network through event streams (emitted by the txns executed for the destination Pipe). The data can be &quot;observed&quot; by any users, but decoded only by the ones having the decryption key.</p><p>The receiving end DTP SDK re-assembles the txns into the original data stream. The stream is then forwarded to the intended end-user (a TCP server, a Rust application layer above etc...).</p><p>Slower transactions (Sui consensus) are used for most &quot;control plane&quot; synchronizations (e.g. opening a connection)</p><h2 id="dtp-glossary" tabindex="-1"><a class="header-anchor" href="#dtp-glossary"><span>DTP Glossary</span></a></h2><p><img src="'+r+'" alt="" loading="lazy"></p><p><strong>Client</strong>: An application that initiate a connection.</p><p><strong>Connection:</strong> One connection allows exchanging data between two applications. The applications are localized by their Host object on the Sui network. A connection will start to exchange data only after a Transport Control and one or two Pipe objects are created (for uni or bidirectional transfer respectively).</p><p><strong>Host Object</strong>: Any signature authority that want to transfer data must create its own Host object. This object is involved in many control plane transactions. It allows to configure the services (and SLA) that are to be provided and control some firewall functions (e.g. limit maximum number of simultaneous open connections).</p>',9),x=e("strong",null,"Objects:",-1),D={href:"https://docs.sui.io/concepts/object-model",target:"_blank",rel:"noopener noreferrer"},S=i('<p><strong>Pipe Object</strong>: All off-chain data exchange involves an intermediate object on the Sui network. This object is the Pipe. It is owned by the sender of the data, and have its event stream observed by the receiver(s). A Pipe is loosely coupled to a Transport or Broadcast Control object for synchronization.</p><p><strong>Server</strong>: Off-chain process intended to respond to client requests.</p><p><strong>Service Level Agreement (SLA)</strong>: Specify the costs, limitations and some behaviors for a service provided by a Host object. Example would be &quot;sent data can be deleted from network storage after 48 hours (2 epochs)&quot;. The client signifies that it agrees to an SLA at the time the connection to the node is initiated. The SLA specs are such that DTP can enforce the agreement fairly to all parties.</p><p><strong>Transport Control Object</strong>: Variables and state machines that exists for the lifetime of a single connection. This is a Sui shared object.</p><h2 id="firewall" tabindex="-1"><a class="header-anchor" href="#firewall"><span>Firewall</span></a></h2><p><img src="'+l+'" alt="" loading="lazy"></p><p>(1) Gas cost of processing incoming traffic is paid by the sender. That includes connection creation cost and running the firewall at the Pipe Object. Most abuse can therefore be neutralized without requiring any processing/cost from the Server.</p><p>Firewall functionality also includes back pressure management to minimize initiating/paying for transactions while the server is already known offline or too busy.</p><p>(2) Optionally, the DTP Host object gather statistics from all its Pipe objects and can adjust the traffic policies, as an example to block an abusing sender. (Note: Synchronization with owned object is a <strong>logical</strong> representation. See <a href="#non-blocking-data-plane">Non-Blocking Data Plane</a> for more design details).</p><p>(3) The server configure the firewall and does a periodical heartbeat using its shared DTP Host object. The DTP services daemon can also be configured to further actively control the firewall depending of its load (TBD).</p><p>(4) When a transmission is block because of the firewall, there is no event emitted (and sender is informed with a transaction error). Statistics are accumulated, but the Server is not impacted.</p><h2 id="non-blocking-data-plane" tabindex="-1"><a class="header-anchor" href="#non-blocking-data-plane"><span>Non-Blocking Data Plane</span></a></h2><p>The owned objects on the data plane (e.g. Pipe) need to synchronize periodically with the control plane. This is for forwarding traffic statistic, apply latest firewall commands and bring the escrows to resolution.</p><p>The control plane typically uses shared object. Involving a single Pipe object with a slow consensus would cause a 2-3 seconds blocking of the data plane. This is unacceptable if streaming audio/video.</p><p>Therefore, a owned Pipe is actually assisted by InnerPipe owned objects. The synchronization between InnerPipe and the slower control plane is done in two steps.</p><ol><li>Each InnerPipe is sequentially &quot;fast synch&quot; with its related Pipe (all fast path).</li><li>The Pipe object is &quot;slow synch&quot; with the control plane. This is a consensus transaction.</li></ol><img src="'+c+`" style="display:block;margin-left:auto;margin-right:auto;"><p>With this design, the data plane flows at &quot;full speed&quot; while keeping all objects <strong>eventually</strong> synchronized.</p><p>The receiver re-assemble the data stream from what is observed from all flowing InnerPipes (DTP has sequence numbers for re-ordering).</p><p>A fast path sync looks like:</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>  fun fast_sync( pipe: &amp;mut Pipe, inner_pipe: &amp;mut InnerPipe ) 
  {
    // ... quickly exchange data plane stats, latest control plane commands etc...
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The slow consensus sync is:</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>  fun slow_sync( pipe: &amp;mut Pipe,                  
                 transport_control: &amp;mut TransportControl )
  {
    // ... does slow control plane operation ...
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The fast path data flowing is:</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>  fun fast_data_send(inner_pipe: &amp;mut InnerPipe, data: vector&lt;u8&gt;) 
  {
    // ... does a fast data plane transmission ...
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Of course, the sender has to be extra careful about equivocation.</p><p>Note 1: DTP &quot;forces&quot; the sender (Pipe/InnerPipe owner) to collaborate. An InnerPipe will automatically block when not &quot;sufficiently&quot; synchronized (e.g. block after 20 transaction without sync). If the sender choose to not follow the &quot;sync&quot; protocol, then the whole Pipe will eventually be blocked/useless. At worst, any party can &quot;hangup&quot; the connection and let DTP do fair final escrows resolutions.</p><p>Note 2: All this design is encapsulated within the DTP protocol and SDKs. The complexity will not be visible at the DTP API level.</p><h2 id="video-streaming" tabindex="-1"><a class="header-anchor" href="#video-streaming"><span>Video Streaming</span></a></h2><p>A media byte stream is eventually divided into transaction. A serialization of these transactions would limit quickly the bandwidth because of the <strong>Sui finality time</strong> and <strong>maximum transaction size</strong>.</p><p>To support high bandwidth, DTP uses multiple InnerPipes for parallel fast path transactions (See <a href="#non-blocking-data-plane">Non-Blocking Data Plane</a>).</p><p>Most of the complexity is handled off-chain by DTP when dividing and re-assembling the transactions into a data stream.</p><p><strong>Will this be practical?</strong> There is still some cost/performance/implementation unknowns that might persist until DTP is further develop...</p><p>Gas might get too expensive, there is also some potential issues with Sui fullnodes performance... (problem at egress of the network, not with the consensus performance itself).</p>`,34),j={href:"https://docs.google.com/spreadsheets/d/1zBrB1ifhPpnLlsDr6nBN_N55Kkw9hX06a7EVUpogyn4/edit?usp=sharing",target:"_blank",rel:"noopener noreferrer"},q=i('<p><img src="'+d+'" alt="" loading="lazy"><em><div style="text-align:center;"><small style="color:red;">(Note: Numbers are best guess as of 02/14/24. Will be revised from time to time)</small></div></em></p><h2 id="high-availability-and-load-balancing" tabindex="-1"><a class="header-anchor" href="#high-availability-and-load-balancing"><span>High-Availability and Load Balancing</span></a></h2><p><img src="'+p+'" alt="" loading="lazy"><em><div style="text-align:center;">Forwarding decision made by Pipe object when multiple end-points (servers)</div></em></p><p>Off-chain servers can share the incoming load or be each other&#39;s fallback for high-availability.</p><p>Unlike traditional network, the data is not physically pushed toward a server. Instead, the data remains on the network and an event is emitted about who should &quot;pull it&quot;.</p><p>It is an off-chain responsibility for the application to subscribe to their respective event stream (with proper identifier filtering) and normally retrieve only its assigned data (this change in some recovery scenario).</p><p>Configuration of the end-points and health of the servers is managed through the DTP node, which in turn updates all its pipes and transport control objects.</p><p>DTP will hide the high complexity of many race conditions (assignment to a server that died) and connection migrations among all end-points belonging to the same Node.</p><h2 id="uni-directional-transfer" tabindex="-1"><a class="header-anchor" href="#uni-directional-transfer"><span>Uni-directional Transfer</span></a></h2><p>Similar to bi-directionals, but with a single Pipe object for data plane to minimize cost/complexity. Control plane still bi-directional (e.g. for encryption handshake).</p><p><img src="'+h+'" alt="" loading="lazy"><em><div style="text-align:center;">Uni-Directional Data Transfer</div></em></p><h2 id="public-broadcasting" tabindex="-1"><a class="header-anchor" href="#public-broadcasting"><span>Public Broadcasting</span></a></h2><p>Similar to unidirectional, but without encryption and using Broadcast objects instead of a Pipe&amp;Transport control.</p><p><img src="'+u+'" alt="" loading="lazy"><em><div style="text-align:center;">Broadcasting Specific Objects</div></em></p><p>Broadcasters may require some different crypto-economic capability. Examples:</p><ul><li>A live broadcast is wasteful if there is no one listening... one option will be to let DTP stop stream until there are enough fund from listeners to cover, say, the production cost of the next 1 minute. DTP would handle the automatic &quot;on air&quot; logic and fairly spread the cost among the contributors.</li><li>Listener may choose to tip a live broadcaster (for special requests?).</li></ul>',16);function A(I,z){const a=o("ExternalLinkIcon"),s=o("RouteLink");return m(),f("div",null,[y,w,_,T,e("p",null,[t("Sui owned objects are used for unidirectional data transfer with sub-second latency (See "),e("a",k,[t("Fast Path Transactions"),n(a)]),t(" in Sui docs).")]),P,e("p",null,[x,t(" Usually refer to Sui objects (See "),e("a",D,[t("Sui Docs"),n(a)])]),S,e("p",null,[t("Some estimations (See on "),e("a",j,[t("Google Sheet"),n(a)]),t("):")]),q,e("p",null,[t("There are also some technical challenges particular to broadcasting (See "),n(s,{to:"/ref/future_work.html#broadcasting-challenges"},{default:b(()=>[t("Future Work")]),_:1}),t(").")])])}const O=g(v,[["render",A],["__file","design.html.vue"]]),C=JSON.parse('{"path":"/ref/design.html","title":"Design","lang":"en-US","frontmatter":{"title":"Design","contributors":true,"editLink":true,"headerDepth":0,"description":"Target Audience Developers should first read the API they intend to use. This document is for developers curious about DTP inner works. At high level, how is the Sui Network use...","head":[["meta",{"property":"og:url","content":"https://dtp.dev/ref/design.html"}],["meta",{"property":"og:site_name","content":"Decentralized Transport Protocol"}],["meta",{"property":"og:title","content":"Design"}],["meta",{"property":"og:description","content":"Target Audience Developers should first read the API they intend to use. This document is for developers curious about DTP inner works. At high level, how is the Sui Network use..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://dtp.dev/assets/images/design_terms.png?url"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Design"}],["meta",{"property":"article:author","content":"dtp.dev"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Design\\",\\"image\\":[\\"https://dtp.dev/assets/images/design_terms.png?url\\",\\"https://dtp.dev/assets/images/ref_firewall.png?url\\",\\"https://dtp.dev/assets/images/multi_channel_est.png?url\\",\\"https://dtp.dev/assets/images/ref_ha.png?url\\",\\"https://dtp.dev/assets/images/ref_uni.png?url\\",\\"https://dtp.dev/assets/images/ref_broadcast.png?url\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"dtp.dev\\",\\"url\\":\\"https://dtp.dev\\"}]}"]]},"headers":[{"level":2,"title":"Target Audience","slug":"target-audience","link":"#target-audience","children":[]},{"level":2,"title":"At high level, how is the Sui Network used?","slug":"at-high-level-how-is-the-sui-network-used","link":"#at-high-level-how-is-the-sui-network-used","children":[]},{"level":2,"title":"DTP Glossary","slug":"dtp-glossary","link":"#dtp-glossary","children":[]},{"level":2,"title":"Firewall","slug":"firewall","link":"#firewall","children":[]},{"level":2,"title":"Non-Blocking Data Plane","slug":"non-blocking-data-plane","link":"#non-blocking-data-plane","children":[]},{"level":2,"title":"Video Streaming","slug":"video-streaming","link":"#video-streaming","children":[]},{"level":2,"title":"High-Availability and Load Balancing","slug":"high-availability-and-load-balancing","link":"#high-availability-and-load-balancing","children":[]},{"level":2,"title":"Uni-directional Transfer","slug":"uni-directional-transfer","link":"#uni-directional-transfer","children":[]},{"level":2,"title":"Public Broadcasting","slug":"public-broadcasting","link":"#public-broadcasting","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.89,"words":1467},"filePathRelative":"ref/design.md","autoDesc":true}');export{O as comp,C as data};
